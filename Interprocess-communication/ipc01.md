#### 管道概述及相关API应用
##### 管道相关的关键概念
管道是 Linux 支持的最初 Unix IPC 形式之一，具有以下特点：

* 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；
* 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；
* 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
* 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

##### 管道的创建

```c
#include <unistd.h>
int pipe(int fd[2])
```
该函数创建的管道的两端处于一个进程中间，在实际应用中没有太大意义，因此，一个进程在由 pipe() 创建管道后，一般再 fork 一个子进程，然后通过管道实现父子进程间的通信（因此也不难推出，只要两个进程中存在亲缘关系，这里的亲缘关系指的是具有共同的祖先，都可以采用管道方式来进行通信）。

##### 管道的读写规则
管道两端可分别用描述字 fd[0] 以及 fd[1] 来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字 fd[0] 表示，称其为管道读端；另一端则只能用于写，由描述字 fd[1] 来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的 I/O 函数都可以用于管道，如 close、read、write 等等。

从管道中读取数据：
* 如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为 0；
* 当管道的写端存在时，如果请求的字节数目大于 `PIPE_BUF`，则返回管道中现有的数据字节数，如果请求的字节数目不大于 `PIPE_BUF`，则返回管道中现有数据字节数（此时，管道中数据量小于请求的数据量）；或者返回请求的字节数（此时，管道中数据量不小于请求的数据量）。注：（`PIPE_BUF` 在`include/linux/limits.h` 中定义，不同的内核版本可能会有所不同。Posix.1 要求 PIPE_BUF 至少为512 字节，red hat 7.2 中为 4096）。

验证 `PIPE_BUF`：

```
haha
```

关于管道的读规则验证：

```
hehe
```

向管道中写入数据：

* 向管道中写入数据大于 `PIPE_BUF`（管道缓冲区大小） 时，linux 将不保证写入的原子性，这里的原子性指的是写操作的数据可能相互穿插。
* 如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。 

注：只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的 `SIFPIPE` 信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。

验证写端对读端存在的依赖性：

```
haha
```

输出结果：
Broken pipe 

原因就是该管道以及它的所有 fork() 产物的读端都已经被关闭。如果在父进程中保留读端，即在写完 pipe 后，再关闭父进程的读端，也会正常写入 pipe，读者可自己验证一下该结论。因此，在向管道写入数据时，至少应该存在某一个进程，其中管道读端没有被关闭，否则就会出现上述错误（管道断裂,进程收到了 `SIGPIPE` 信号，默认动作是进程终止）

验证写入管道的原子性：

```
hehe
```

##### 管道应用实例

###### 实例一：用于shell
管道可用于输入输出重定向，它将一个命令的输出直接定向到另一个命令的输入。比如，当在某个 shell 程序（Bourne shell 或 C shell 等）键入 who│wc -l 后，相应 shell 程序将创建 who 以及 wc 两个进程和这两个进程间的管道。考虑下面的命令行：

```shell
$kill -l | grep SIGRTMIN
```

运行结果如下：

```
30) SIGPWR	31) SIGSYS	32) SIGRTMIN	33) SIGRTMIN+1
34) SIGRTMIN+2	35) SIGRTMIN+3	36) SIGRTMIN+4	37) SIGRTMIN+5
38) SIGRTMIN+6	39) SIGRTMIN+7	40) SIGRTMIN+8	41) SIGRTMIN+9
42) SIGRTMIN+10	43) SIGRTMIN+11	44) SIGRTMIN+12	45) SIGRTMIN+13
46) SIGRTMIN+14	47) SIGRTMIN+15	48) SIGRTMAX-15	49) SIGRTMAX-14
```

###### 实例二：用于具有亲缘关系的进程间通信
下面例子给出了管道的具体应用，父进程通过管道发送一些命令给子进程，子进程解析命令，并根据命令作相应处理。

```
hehe
```

##### 管道的局限性
管道的主要局限性正体现在它的特点上：

* 只支持单向数据流
* 只能用于具有亲缘关系的进程之间
* 没有名字
* 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）
* 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；

#### 有名管道概述及相关API应用
##### 有名管道相关的关键概念
管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间通信，在有名管道（named pipe或FIFO）提出后，该限制得到了克服。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。

##### 有名管道的创建

```c
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char * pathname, mode_t mode)
```

该函数的第一个参数是一个普通的路径名，也就是创建后 FIFO 的名字。第二个参数与打开普通文件的`open()` 函数中的 mode 参数相同。 如果 mkfifo 的第一个参数是一个已经存在的路径名时，会返回 EEXIST 错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开 FIFO 的函数就可以了。一般文件的 I/O 函数都可以用于 FIFO，如 close、read、write 等等。

##### 有名管道的打开规则
有名管道比管道多了一个打开操作：open。

FIFO的打开规则：

如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该 FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该 FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。

如果当前打开操作是为写而打开 FIFO 时，如果已经有相应进程为读而打开该 FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该 FIFO（当前打开操作设置了阻塞标志）；或者，返回 ENXIO 错误（当前打开操作没有设置阻塞标志）。

#### 有名管道的读写规则
###### 从 FIFO 中读取数据：

约定：如果一个进程为了从 FIFO 中读取数据而阻塞打开 FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。

* 如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。
* 对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：当前FIFO内有数据，但有其它进程在读这些数据；另外就是FIFO内没有数据。解阻塞的原因则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求多少数据量。
* 读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。
* 如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。

注：如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。

###### 向FIFO中写入数据：

约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。

对于设置了阻塞标志的写操作：
* 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。
* 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。

对于没有设置阻塞标志的写操作：
* 当要写入的数据量大于 PIPE_BUF 时，linux 将不再保证写入的原子性。在写满所有 FIFO 空闲缓冲区后，写操作返回。
* 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；

###### 对FIFO读写规则的验证:
下面提供了两个对FIFO的读写程序，适当调节程序中的很少地方或者程序的命令行参数就可以对各种FIFO读写规则进行验证。

程序1：写 FIFO 的程序

程序2：与程序1一起测试写FIFO的规则，第一个命令行参数是请求从FIFO读出的字节数

程序应用说明：
把读程序编译成两个不同版本：

* 阻塞读版本:br
* 非阻塞读版本nbr

把写程序编译成两个四个版本：

* 非阻塞且请求写的字节数大于PIPE_BUF版本：nbwg
* 非阻塞且请求写的字节数不大于PIPE_BUF版本：版本nbw
* 阻塞且请求写的字节数大于PIPE_BUF版本：bwg
* 阻塞且请求写的字节数不大于PIPE_BUF版本：版本bw

下面将使用br、nbr、w代替相应程序中的阻塞读、非阻塞读
验证阻塞写操作：

1. 当请求写入的数据量大于PIPE_BUF时的非原子性：
	 * nbr 1000
	 * bwg
2. 当请求写入的数据量不大于 PIPE_BUF 时的原子性： 
	* nbr 1000
	* bw

验证非阻塞写操作：

1. 当请求写入的数据量大于PIPE_BUF时的非原子性
	* nbr 1000
	* nbwg
2. 请求写入的数据量不大于PIPE_BUF时的原子性
	* nbr 1000
	* nbw

不管写打开的阻塞标志是否设置，在请求写入的字节数大于 4096 时，都不保证写入的原子性。但二者有本质区别：
对于阻塞写来说，写操作在写满 FIFO 的空闲区域后，会一直等待，直到写完所有数据为止，请求写入的数据最终都会写入 FIFO；
而非阻塞写则在写满 FIFO 的空闲区域后，就返回(实际写入的字节数)，所以有些数据最终不能够写入。

对于读操作的验证则比较简单，不再讨论。 

#### 小结

管道常用于两个方面：

 1. 在shell中时常会用到管道（作为输入输入的重定向），在这种应用方式下，管道的创建对于用户来说是透明的；
 2. 用于具有亲缘关系的进程间通信，用户自己创建管道，并完成读写操作。

* FIFO 可以说是管道的推广，克服了管道无名字的限制，使得无亲缘关系的进程同样可以采用先进先出的通信机制进行通信。
* 管道和 FIFO 的数据是字节流，应用程序之间必须事先确定特定的传输"协议"，采用传播具有特定意义的消息。
* 要灵活应用管道及 FIFO，理解它们的读写规则是关键。
