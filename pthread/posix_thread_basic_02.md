### 线程建立与使用
#### 创建线程

* 通过pthread_create()函数创建线程；
  * 向该函数传递线程函数地址和线程函数参数；
  * 线程函数只有一个void*参数；
  * 该函数返回pthread_t类型的线程ID；
* 一般调用该函数创建线程，然后调用pthread_join()函数等待线程结束；
  * 在当前线程从函数pthread_create()中返回以及新线程被调度执行之间不存在同步关系；
  * 新线程可能在当前线程从pthread_create()返回值前就运行了；
  * 或在当前线程从pthread_create()返回之前，新线程就可能已经运行完毕了；

##### pthread_join()

* 阻塞其调用者直到指定线程终止，然后可以选择地保存线程的返回值；
* 当pthread_join()调用返回时，被连接线程就已经被分离(detached)，再也不能连接该线程了；
* 如果连接(joining)线程不关心返回值，或者它知道被连接(joined)的线程根本不返回任何值，则可向pthread_join()的&retval参数传递NULL，此时，被连接线程的返回值将被忽略；

如何使用可参考pthread_create()、pthread_join()手册；

#### 初始线程

* C 程序运行时，首先运行 main() 函数，main() 函数所在线程称为初始线程或主线程；
* 初始线程可调用 pthread_self() 获得其ID，也可调用 pthread_exit() 来终止自己；
* 从 main() 返回将导致进程终止，也将使进程内所用线程终止；
* 在 main() 中调用 pthread_exit()，这样进程就必须等待所有线程结束后才能终止；
* 若初始线程将其 ID 保存在一个其他线程可以访问的空间，则其他线程就可以等待初始线程的终止或者分离初始线程；

#### 线程分离

* 分离一个正在运行的线程不会对线程带来任何影响，仅仅是通知系统当该线程结束时，其所属资源可以被回收；
* 分离线程意味着通知系统不再需要此线程，允许系统将分配给它的资源回收；
* 一个没有被分离的线程终止时会保留其虚拟内存，包括堆栈和其他系统资源。

### 线程生命周期
在任意时刻，线程处于下表的四个基本状态之一。

<table>
<tr>
  <td>状态</td>
  <td>说明</td>
</tr>
<tr>
  <td>就绪 ready</td>
  <td>
  线程能够运行，但在等待可用的处理器；
    <ul>
      <li>可能刚刚启动</li>
      <li>或刚刚从阻塞中恢复</li>
      <li>或被其他线程抢占</li>
    </ul>
  </td>
</tr>
<tr>
  <td>运行 running</td>
  <td>线程正在运行；在多处理器系统中，可能有多个线程处于运行状态；</td>
</tr>
<tr>
  <td>阻塞 blocked /td>
  <td>线程由于等待处理器外的其他条件无法运行，如条件变量的改变、加锁互斥量或IO操作结束；</td>
</tr>
<tr>
  <td>终止 terminated</td>
  <td>
  不是被分离，也不是被连接，一旦线程被分离或者连接，它就可以被回收；
    <ul>
      <li>线程从起始函数中返回</li>
      <li>或调用pthread_exit</li>
      <li>或被取消，终止自己并完成所有资源清理工作</li>
    </ul>
  </td>
</tr>
</table>


线程状态转换如下图。

![thread](http://img.my.csdn.net/uploads/201209/07/1347032132_4377.png)

#### 说明

* 线程开始处于就绪状态；
* 当线程运行时，它调用特定的起始函数；
* 它可能被其他线程抢占，或者因等待外来事情而阻塞自己；
* 最终线程完成工作，或者从起始函数返回，或者调用pthread_exit函数，即进入终止状态；
* 如果线程已被分离，则它立刻被回收重用；否则，线程停留在终止状态直到被分离或被连接；

#### 就绪态

* 线程刚被创建时；
* 线程被解除阻塞再次可以运行时；
* 运行线程被抢占时，如时间片到；

#### 被阻塞

